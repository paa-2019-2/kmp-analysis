(merge_sort_correctness
 (merge_preserves_occurrences 0
  (merge_preserves_occurrences-1 nil 3781005711
   ("" (skolem 1 ("_" "_" "n"))
    (("" (measure-induct "length(l1) + length(l2)" (l1 l2))
      (("" (skeep)
        (("" (case "x_1 = null")
          (("1" (expand "merge" 1)
            (("1" (assert)
              (("1" (expand "append" 1)
                (("1" (expand "occurrences" 1) (("1" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "merge" 2)
            (("2" (case "x_2 = null")
              (("1" (assert)
                (("1" (replace -1 2)
                  (("1" (rewrite "append_null")
                    (("1" (expand "occurrences" 2 2)
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (lift-if)
                  (("2" (prop)
                    (("1" (expand "occurrences" 1 (1 2))
                      (("1" (lift-if)
                        (("1" (assert) (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (expand "occurrences" 2 (1 3))
                      (("2" (lift-if)
                        (("2" (assert)
                          (("2" (inst -1 "x_1" "cdr(x_2)")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (append_null formula-decl nil list_props nil)
    (append def-decl "list[T]" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (occurrences def-decl "nat" sorting nil)
    (merge def-decl "list[nat]" mergesort nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (append_null_2 0
  (append_null_2-1 nil 3781275183
   ("" (induct l)
    (("1" (assert)
      (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)
     ("2" (skeep)
      (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (merge_sort_prop_TCC1 0
  (merge_sort_prop_TCC1-1 nil 3781369404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (is_sorted? const-decl "bool" sorting nil))
   nil))
 (merge_sort_prop_TCC2 0
  (merge_sort_prop_TCC2-1 nil 3781369404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (is_sorted? const-decl "bool" sorting nil))
   nil))
 (merge_sort_prop 0
  (merge_sort_prop-1 nil 3781379834 ("" (postpone) nil nil) nil
   shostak))
 (merge_preserves_len 0
  (merge_preserves_len-1 nil 3780873327
   ("" (measure-induct "length(l1) + length(l2)" (l1 l2))
    (("" (skeep)
      (("" (expand "merge" 1)
        (("" (lift-if)
          (("" (prop)
            (("1" (rewrite "length_append") nil nil)
             ("2" (rewrite "length_append") nil nil)
             ("3" (expand "length" 1 1)
              (("3" (inst -2 "cdr(x_1)" "x_2")
                (("3" (prop)
                  (("1" (expand "length" 1 2)
                    (("1" (assert)
                      (("1" (replaces)
                        (("1" (expand "length" 1 3)
                          (("1" (replaces)
                            (("1" (expand "length" -1 2)
                              (("1"
                                (expand "merge" -1)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (prop)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("4" (expand "length" 2 1)
              (("4" (inst -1 "x_1" "cdr(x_2)")
                (("4" (prop)
                  (("1" (expand "length" 2 3)
                    (("1" (replaces)
                      (("1" (expand "length" 2 1)
                        (("1" (replaces)
                          (("1" (expand "length" -1 1)
                            (("1" (expand "merge" -1)
                              (("1"
                                (lift-if)
                                (("1"
                                  (prop)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (prop)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (merge def-decl "list[nat]" mergesort nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length_append formula-decl nil list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (append def-decl "list[T]" list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers
     nil))
   shostak))
 (merge_permutes 0
  (merge_permutes-1 nil 3780935773
   ("" (skeep)
    (("" (expand "permutations")
      (("" (skeep)
        (("" (lemma "occurrences_of_app")
          (("" (inst -1 "l1" "l2" "x")
            (("" (replace -1 1 lr)
              (("" (hide -1)
                (("" (lemma "merge_preserves_occurrences")
                  (("" (inst -1 "l1" "l2" "x") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (merge_preserves_occurrences formula-decl nil
     merge_sort_correctness nil)
    (occurrences_of_app formula-decl nil sorting nil)
    (permutations const-decl "bool" sorting nil))
   shostak))
 (merge_keep_sorted 0
  (merge_keep_sorted-1 nil 3781049724
   ("" (measure-induct "length(l1) + length(l2)" (l1 l2))
    (("" (skeep)
      (("" (expand "merge" 1)
        (("" (prop)
          (("1" (case "x_1 = null")
            (("1" (replaces) (("1" (rewrite "append_null_2") nil nil))
              nil)
             ("2" (assert) nil nil))
            nil)
           ("2" (case "x_2 = null")
            (("1" (replaces) (("1" (rewrite "append_null") nil nil))
              nil)
             ("2" (assert) nil nil))
            nil)
           ("3" (expand "is_sorted?" 1)
            (("3" (skeep)
              (("3" (case "k = 0")
                (("1" (expand "nth")
                  (("1" (expand "nth")
                    (("1" (assert)
                      (("1" (expand "merge" 1)
                        (("1" (assert)
                          (("1" (case "cdr(x_1) = null")
                            (("1" (assert)
                              (("1"
                                (replaces)
                                (("1"
                                  (rewrite "append_null_2")
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (lift-if)
                                (("2"
                                  (prop)
                                  (("2"
                                    (expand "is_sorted?" -6)
                                    (("2"
                                      (inst -6 0)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (expand "nth")
                    (("2" (assert)
                      (("2" (inst -3 "cdr(x_1)" "x_2")
                        (("2" (prop)
                          (("1" (expand "is_sorted?" -1)
                            (("1" (inst -1 "k-1")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (lemma "cdr_of_sorted_is_sorted")
                            (("2" (inst -1 "x_1")
                              (("2" (prop) nil nil)) nil))
                            nil)
                           ("3" (expand "length" 1 3)
                            (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("4" (expand "is_sorted?" 2)
            (("4" (skeep)
              (("4" (case "k = 0")
                (("1" (expand "nth")
                  (("1" (expand "nth")
                    (("1" (assert)
                      (("1" (expand "merge" 2)
                        (("1" (case "x_2 = null")
                          (("1" (assert) nil nil)
                           ("2" (assert)
                            (("2" (lift-if)
                              (("2"
                                (prop)
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil)
                                 ("3"
                                  (expand "is_sorted?" -5)
                                  (("3"
                                    (inst -5 0)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "nth")
                  (("2" (expand "nth")
                    (("2" (assert)
                      (("2" (inst -2 "x_1" "cdr(x_2)")
                        (("2" (expand "length" -2 4)
                          (("2" (rewrite "cdr_of_sorted_is_sorted")
                            (("2" (expand "is_sorted?" -2)
                              (("2"
                                (inst -2 "k-1")
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (merge def-decl "list[nat]" mergesort nil)
    (is_sorted? const-decl "bool" sorting nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (k skolem-const-decl
     "below[list2finseq(cons(car(x_2), merge(x_1, cdr(x_2))))`length]"
     merge_sort_correctness nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (x_1 skolem-const-decl "list[nat]" merge_sort_correctness nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nth def-decl "T" list_props nil)
    (cdr_of_sorted_is_sorted formula-decl nil sorting nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (k skolem-const-decl
     "below[list2finseq(cons(car(x_1), merge(cdr(x_1), x_2)))`length]"
     merge_sort_correctness nil)
    (x_2 skolem-const-decl "list[nat]" merge_sort_correctness nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (append_null formula-decl nil list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append_null_2 formula-decl nil merge_sort_correctness nil))
   shostak))
 (mergesort_preserves_len 0
  (mergesort_preserves_len-1 nil 3780995111
   ("" (measure-induct "length(l)" l)
    (("" (skeep)
      (("" (expand "merge_sort" 1)
        (("" (lift-if)
          (("" (prop)
            (("" (lemma "merge_preserves_len")
              ((""
                (inst -1 "merge_sort(prefix(x, floor(length(x) / 2)))"
                 "merge_sort(suffix(x, floor(length(x) / 2)))")
                (("" (replace -1 (2) RL)
                  (("" (inst-cp -2 "prefix(x, floor(length(x) / 2))")
                    (("" (inst -2 "suffix(x, floor(length(x) / 2))")
                      (("" (hide -1 1)
                        (("" (rewrite "length_prefix")
                          (("" (rewrite "length_suffix")
                            (("" (prop)
                              (("1" (assert) nil nil)
                               ("2" (grind) nil nil)
                               ("3"
                                (assert)
                                (("3" (grind) nil nil))
                                nil)
                               ("4" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (merge_sort def-decl "list[nat]" mergesort nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (prefix def-decl "list[nat]" sorting nil)
    (integer nonempty-type-from-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (suffix def-decl "list[nat]" sorting nil)
    (length_suffix formula-decl nil sorting nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_prefix formula-decl nil sorting nil)
    (merge_preserves_len formula-decl nil merge_sort_correctness nil))
   shostak))
 (mergesort_permutes 0
  (mergesort_permutes-1 nil 3780950637
   ("" (measure-induct "length(l)" l)
    (("" (skeep)
      (("" (expand "permutations")
        (("" (skeep)
          (("" (expand "merge_sort" 1)
            (("" (lift-if)
              (("" (prop)
                (("" (inst-cp -1 "prefix(x, floor(length(x) / 2))")
                  (("" (inst -1 "suffix(x, floor(length(x) / 2))")
                    (("" (assert)
                      (("" (rewrite "length_suffix")
                        (("" (rewrite "length_prefix")
                          (("" (assert)
                            (("" (lemma "merge_preserves_occurrences")
                              ((""
                                (inst
                                 -1
                                 "merge_sort(prefix(x, floor(length(x) / 2)))"
                                 "merge_sort(suffix(x, floor(length(x) / 2)))"
                                 "x_1")
                                ((""
                                  (replaces -1)
                                  ((""
                                    (replace -1 2 rl)
                                    ((""
                                      (inst -2 "x_1")
                                      ((""
                                        (inst -3 "x_1")
                                        ((""
                                          (replace -2 2 rl)
                                          ((""
                                            (replace -3 2 rl)
                                            ((""
                                              (lemma
                                               "app_prefix_suffix")
                                              ((""
                                                (hide -2 -3 -4 1)
                                                ((""
                                                  (inst
                                                   -1
                                                   "x"
                                                   "floor(length(x) / 2)")
                                                  ((""
                                                    (lemma
                                                     "occurrences_of_app")
                                                    ((""
                                                      (inst
                                                       -1
                                                       "prefix(x, floor(length(x) / 2))"
                                                       "suffix(x, floor(length(x) / 2))"
                                                       "x_1")
                                                      ((""
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (prefix def-decl "list[nat]" sorting nil)
    (integer nonempty-type-from-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length_prefix formula-decl nil sorting nil)
    (merge_preserves_occurrences formula-decl nil
     merge_sort_correctness nil)
    (app_prefix_suffix formula-decl nil sorting nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (occurrences_of_app formula-decl nil sorting nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length_suffix formula-decl nil sorting nil)
    (suffix def-decl "list[nat]" sorting nil)
    (permutations const-decl "bool" sorting nil)
    (merge_sort def-decl "list[nat]" mergesort nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (mergesort_sorts 0
  (mergesort_sorts-1 nil 3780946864
   ("" (measure-induct "length(l)" l)
    (("" (skeep)
      (("" (expand "merge_sort" 1)
        (("" (prop)
          (("1" (expand "is_sorted?" 1)
            (("1" (skeep)
              (("1" (expand "length" -2)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (assert) nil nil)
                     ("2" (expand "length" -2)
                      (("2" (lift-if)
                        (("2" (prop) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "merge_keep_sorted")
            (("2"
              (inst -1 "merge_sort(prefix(x, floor(length(x) / 2)))"
               "merge_sort(suffix(x, floor(length(x) / 2)))")
              (("2" (split)
                (("1" (propax) nil nil)
                 ("2" (inst -1 "prefix(x, floor(length(x) / 2))")
                  (("2" (rewrite "length_prefix")
                    (("2" (assert) nil nil)) nil))
                  nil)
                 ("3" (inst -1 "suffix(x, floor(length(x) / 2))")
                  (("3" (assert)
                    (("3" (rewrite "length_suffix")
                      (("3" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (merge_sort def-decl "list[nat]" mergesort nil)
    (is_sorted? const-decl "bool" sorting nil)
    (merge_keep_sorted formula-decl nil merge_sort_correctness nil)
    (length_prefix formula-decl nil sorting nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length_suffix formula-decl nil sorting nil)
    (suffix def-decl "list[nat]" sorting nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (<= const-decl "bool" reals nil)
    (integer nonempty-type-from-decl nil integers nil)
    (prefix def-decl "list[nat]" sorting nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (mergesort_correctness 0
  (mergesort_correctness-1 nil 3780945719
   ("" (skeep)
    (("" (split)
      (("1" (lemma "mergesort_sorts") (("1" (inst?) nil nil)) nil)
       ("2" (lemma "mergesort_permutes") (("2" (inst?) nil nil)) nil))
      nil))
    nil)
   ((mergesort_permutes formula-decl nil merge_sort_correctness nil)
    (mergesort_sorts formula-decl nil merge_sort_correctness nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (merge_null_is_sorted 0
  (merge_null_is_sorted-1 nil 3781369405
   ("" (induct l)
    (("1" (flatten)
      (("1" (expand "merge")
        (("1" (expand "append") (("1" (prop) nil nil)) nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (prop)
        (("1" (expand "merge" 1)
          (("1" (rewrite "append_null_2") nil nil)) nil)
         ("2" (expand "merge" 1)
          (("2" (rewrite "append_null") nil nil)) nil)
         ("3" (expand "merge" 1)
          (("3" (rewrite "append_null_2") nil nil)) nil)
         ("4" (expand "merge" 1)
          (("4" (rewrite "append_null") nil nil)) nil))
        nil))
      nil))
    nil)
   ((append_null formula-decl nil list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append_null_2 formula-decl nil merge_sort_correctness nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (merge def-decl "list[nat]" mergesort nil)
    (is_sorted? const-decl "bool" sorting nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak)))

